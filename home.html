<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Reels App</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet"/>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background-color: #000;
      color: white;
    }
    #app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      position: relative;
    }
    .app-header {
      height: 50px;
      background-color: #1a1a1a;
      display: flex;
      justify-content: space-between; /* Changed to space-between */
      align-items: center;
      border-bottom: 1px solid #333;
      font-weight: bold;
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 101;
      padding: 0 15px;
      box-sizing: border-box;
    }
    .app-header .header-title {
        flex-grow: 1;
        text-align: center;
    }

    /* New styles for header tabs */
    .header-tabs {
        display: flex;
        justify-content: center;
        width: 100%;
        gap: 20px; /* Space between tabs */
        flex-grow: 1; /* Allow tabs to take available space */
    }
    .header-tab {
        color: #ccc;
        text-decoration: none;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 1em;
        position: relative;
    }
    .header-tab.active {
        color: white;
        font-weight: bold;
    }
    .header-tab.active::after {
        content: '';
        position: absolute;
        bottom: -5px;
        left: 0;
        width: 100%;
        height: 2px;
        background-color: #007bff;
    }

    /* Styles for the drawer icon */
    .drawer-icon {
        color: white;
        font-size: 1.5em;
        cursor: pointer;
        margin-right: 15px; /* Space between icon and tabs */
        z-index: 102; /* Ensure it's above other elements */
    }

    /* Styles for the drawer menu */
    .drawer-menu {
        position: fixed;
        top: 50px; /* Below the header */
        left: 0;
        width: 250px; /* Adjust width as needed */
        height: calc(100vh - 50px);
        background-color: #1f1f1f;
        box-shadow: 2px 0 5px rgba(0,0,0,0.5);
        transform: translateX(-100%);
        transition: transform 0.3s ease-out;
        z-index: 100;
        padding-top: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
    }
    .drawer-menu.show {
        transform: translateX(0);
    }
    .drawer-menu ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    .drawer-menu ul li {
        padding: 12px 20px;
        border-bottom: 1px solid #333;
        cursor: pointer;
        color: #ccc;
        font-size: 1.1em;
        transition: background-color 0.2s ease, color 0.2s ease;
    }
    .drawer-menu ul li:hover {
        background-color: #333;
        color: white;
    }
    .drawer-menu ul li:last-child {
        border-bottom: none;
    }


    #reels-feed {
      flex-grow: 1;
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      scroll-padding-top: 50px;
      padding-top: 50px;
      padding-bottom: 60px;
      box-sizing: border-box;
      position: relative; /* Added for loading GIF positioning */
    }
    
    /* New styles for loading GIF */
    .loading-gif-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 50; /* Ensure it's above the feed content but below headers */
        background-color: rgba(0, 0, 0, 0.7); /* Optional: semi-transparent background */
        width: 100%;
        height: calc(100vh - 110px); /* Adjust height to cover feed area */
        opacity: 1;
        visibility: visible;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .loading-gif-container.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Prevent interaction when hidden */
    }

    .loading-gif {
        width: 400px; /* Adjust size as needed */
        height: 40px; /* Adjust size as needed */
        object-fit: contain;
    }


    .reel-item {
      scroll-snap-align: start;
      height: calc(100vh - 50px - 60px);
      width: 100vw;
      position: relative;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    .reel-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .reel-overlay {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      padding: 0 15px;
      box-sizing: border-box;
      background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
    }
    .reel-username-line {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .reel-username {
      margin-right: 5px;
    }
    .follow-button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.8em;
      margin-left: 10px;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    .follow-button.following {
      background-color: #555;
      color: #ccc;
    }
    .follow-button.following:hover {
        background-color: #666;
        color: white;
    }
    .follow-button:hover:not(.following) {
        background-color: #0056b3;
    }

    .profile-pic-container {
      position: absolute;
      right: 15px;
      bottom: 350px; /* Adjusted: Moved higher */
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 20;
    }
    .profile-pic {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #555;
      object-fit: cover;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2em;
      font-weight: bold;
      color: white;
      text-transform: uppercase;
      border: 2px solid white;
      margin-bottom: 10px;
    }
    .profile-pic.placeholder {
        background-color: #555;
        border: 2px solid white;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.2em;
        font-weight: bold;
        color: white;
        text-transform: uppercase;
    }
    /* Styles for the SVG verified tick */
    .verified-tick-svg {
        width: 1em; /* Adjust as needed */
        height: 1em; /* Adjust as needed */
        margin-left: 5px; /* Space from text */
        vertical-align: middle; /* Align with text */
    }
    .verified-tick-svg circle {
        fill: #007bff; /* Blue color for the circle */
    }
    .verified-tick-svg path {
        fill: white; /* White color for the checkmark */
    }

    .mute-indicator {
      position: absolute;
      top: 70px;
      right: 20px;
      background-color: rgba(0,0,0,0.5);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2em;
      z-index: 15;
      cursor: pointer;
      transition: opacity 0.3s ease;
    }
    .mute-indicator.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .footer-nav {
      position: fixed;
      bottom: 0;
      height: 60px;
      width: 100%;
      background-color: #1a1a1a;
      display: flex;
      justify-content: space-around;
      align-items: center;
      border-top: 1px solid #333;
      z-index: 100;
    }
    .footer-nav a {
      color: #ccc;
      text-decoration: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.8em;
    }
    .footer-nav a:hover, .footer-nav a.active {
      color: #007bff;
    }
    .footer-nav i {
      font-size: 1.5em;
      margin-bottom: 4px;
    }
    .hidden {
      display: none !important;
    }
    .reel-actions {
      position: absolute;
      right: 15px;
      bottom: 110px; /* This remains the same as previously adjusted */
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      z-index: 20;
    }
    .reel-action-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
    }
    .reel-action-item i {
      font-size: 2.2em;
      margin-bottom: 5px;
    }
    .reel-action-item i.liked {
      color: red;
    }
    .reel-action-item span {
      font-size: 0.9em;
    }

    /* Styles for the comments modal */
    .comments-modal {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 70%;
      background-color: #1a1a1a;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
      transform: translateY(100%);
      transition: transform 0.3s ease-out;
      z-index: 102;
      display: flex;
      flex-direction: column;
      padding: 15px;
      box-sizing: border-box;
    }
    .comments-modal.show {
      transform: translateY(0);
    }
    .comments-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
      margin-bottom: 10px;
    }
    .comments-header h3 {
      margin: 0;
      font-size: 1.1em;
    }
    .comments-header .close-btn {
      background: none;
      border: none;
      color: white;
      font-size: 1.5em;
      cursor: pointer;
    }
    .comments-list {
      flex-grow: 1;
      overflow-y: auto;
      padding-right: 5px;
    }
    .comment-item {
      display: flex;
      margin-bottom: 15px;
      align-items: flex-start;
      position: relative;
    }
    .comment-user-pic {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: #555;
      object-fit: cover;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 0.8em;
      font-weight: bold;
      color: white;
      text-transform: uppercase;
      border: 1px solid white;
      margin-right: 10px;
      flex-shrink: 0;
    }
    .comment-user-pic.placeholder {
      background-color: #555;
      border: 1px solid white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 0.8em;
      font-weight: bold;
      color: white;
      text-transform: uppercase;
    }
    .comment-content {
      flex-grow: 1;
    }
    .comment-username {
      font-weight: bold;
      margin-right: 5px;
      font-size: 0.9em;
      display: flex; /* To align verified tick with username */
      align-items: center;
    }
    .comment-text {
      font-size: 0.9em;
      line-height: 1.4;
      word-wrap: break-word;
    }
    .comment-actions {
      display: flex;
      align-items: center;
      font-size: 0.7em;
      color: #aaa;
      margin-top: 5px;
    }
    .comment-actions span {
      margin-right: 10px;
    }
    .comment-actions .like-comment-btn {
        cursor: pointer;
        margin-right: 5px;
        color: #aaa;
    }
    .comment-actions .like-comment-btn.liked {
        color: red;
    }
    .comment-actions .like-count {
        margin-right: 10px;
        font-size: 0.8em;
    }
    /* Verified tick for comments */
    .comment-username .verified-tick-svg {
        width: 0.8em; /* Slightly smaller for comments */
        height: 0.8em;
        margin-left: 3px;
    }

    /* New styles for in-modal comment input */
    .comment-input-area {
      padding: 15px;
      border-top: 1px solid #333;
      display: flex;
      gap: 10px;
      align-items: center;
      box-sizing: border-box;
      width: 100%; /* Ensure it takes full width initially */
      max-width: 95%; /* Limit the maximum width for better mobile fit */
      margin: 0 auto; /* Center the box horizontally */
    }
    .comment-input-area input {
      flex-grow: 1;
      padding: 10px 15px;
      border: 1px solid #444;
      background-color: #2a2a2a;
      color: white;
      outline: none;
      border-radius: 20px; /* Pill shape */
      font-size: 0.95em;
      box-sizing: border-box;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
      min-width: 0; /* Allow input to shrink appropriately */
    }
    .comment-input-area input:focus {
      border-color: #007bff;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.3);
    }
    .comment-input-area #postCommentBtn {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 15px; /* Slightly reduce padding for button to fit */
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
      font-size: 0.9em;
      transition: background-color 0.2s ease, transform 0.2s ease;
      flex-shrink: 0; /* Prevent button from shrinking */
    }
    .comment-input-area #postCommentBtn:hover {
      background-color: #0056b3;
      transform: translateY(-1px);
    }
    .comment-input-area #postCommentBtn:active {
      transform: translateY(0);
    }


    /* Three Dots Menu for comments and reels */
    .options-container {
        position: relative;
        display: inline-block;
    }
    .options-btn {
        background: none;
        border: none;
        color: #aaa;
        font-size: 1.2em;
        cursor: pointer;
        padding: 5px;
    }
    /* Reel options menu specific styling */
    .reel-options-menu {
        position: absolute;
        bottom: 50px; /* Adjust as needed to be above the button */
        right: 0;
        background-color: #333;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        z-index: 20;
        min-width: 120px;
        display: none;
        flex-direction: column; /* To stack buttons vertically */
    }
    .reel-options-menu.show {
        display: flex; /* Changed from block to flex */
    }
    .reel-options-menu button {
        background: none;
        border: none;
        color: white;
        padding: 8px 12px;
        width: 100%;
        text-align: left;
        cursor: pointer;
        font-size: 0.9em;
    }
    .reel-options-menu button:hover {
        background-color: #555;
    }

    /* Comment options menu */
    .comment-options {
        position: relative;
        display: inline-block;
        margin-left: auto; /* Push to the right */
    }
    .comment-options-btn { /* Changed from .options-btn to be specific */
        background: none;
        border: none;
        color: #aaa;
        font-size: 1.2em;
        cursor: pointer;
        padding: 5px;
    }
    .comment-options-menu {
        position: absolute;
        top: 25px;
        right: 0;
        background-color: #333;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        z-index: 10;
        min-width: 100px;
        display: none;
    }
    .comment-options-menu.show {
        display: block;
    }
    .comment-options-menu button {
        background: none;
        border: none;
        color: white;
        padding: 8px 12px;
        width: 100%;
        text-align: left;
        cursor: pointer;
        font-size: 0.9em;
    }
    .comment-options-menu button:hover {
        background-color: #555;
    }

    /* New styles for the rotating disk */
    .rotating-disk-container {
        position: absolute;
        right: 15px;
        bottom: 50px; /* This remains the same as previously adjusted */
        display: flex;
        flex-direction: column;
        align-items: center;
        z-index: 20;
    }

    .rotating-disk {
        width: 45px; /* Slightly larger than profile pic */
        height: 45px;
        border-radius: 50%;
        background-color: #333; /* Disk background */
        border: 5px solid #555; /* Simulate record grooves */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        animation: rotateDisk 3s linear infinite; /* Animation for rotation */
        position: relative;
    }

    .rotating-disk img {
        width: 25px; /* Profile picture size inside disk */
        height: 25px;
        border-radius: 50%;
        object-fit: cover;
        border: 1px solid white; /* Border for the profile pic inside the disk */
    }

    .rotating-disk .placeholder {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background-color: #777;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7em;
        font-weight: bold;
        color: white;
        text-transform: uppercase;
        border: 1px solid white;
    }

    @keyframes rotateDisk {
        from {
            transform: rotate(0deg);
        }
        to {
            transform: rotate(360deg);
        }
    }
    /* Styles for view count on home.html */
    .views-count-display {
      position: absolute;
      bottom: 18px; /* Above the overlay */
      left: 15px;
      color: white;
      font-size: 0.9em;
      display: flex;
      align-items: center;
      gap: 5px;
      z-index: 21; /* Above overlay */
      text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
    }

    /* --- Language Selection Modal Styles --- */
    .language-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200; /* Higher than other modals */
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .language-modal-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .language-modal-content {
      background-color: #1a1a1a;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      position: relative;
    }

    .language-modal-content h2 {
      margin-top: 0;
      margin-bottom: 25px;
      color: white;
      font-size: 1.3em;
    }

    .language-options {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-bottom: 30px;
    }

    .language-option {
      background-color: #333;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px 15px;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
      position: relative;
      font-size: 0.95em;
      min-width: 90px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .language-option:hover {
      background-color: #444;
      border-color: #007bff;
    }

    .language-option input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
    }

    .language-option input[type="checkbox"]:checked + span {
      background-color: #007bff;
      border-color: #007bff;
      color: white;
    }

    .language-option span {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 5px;
      line-height: 1.2;
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
      padding: 5px; /* Inner padding for the text */
    }

    .language-modal-content button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s ease;
      width: 100%;
    }

    .language-modal-content button:hover {
      background-color: #0056b3;
    }

    .language-modal-content .skip-btn {
        background: none;
        color: #007bff;
        border: none;
        margin-top: 15px;
        font-size: 0.9em;
        cursor: pointer;
        transition: color 0.2s ease;
    }

    .language-modal-content .skip-btn:hover {
        color: #0056b3;
    }

    /* New styles for Double Tap Heart Animation */
    .double-tap-heart-animation {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 8em; /* Large heart */
      color: white; /* White color */
      opacity: 0;
      pointer-events: none; /* Make sure it doesn't block video clicks */
      transition: opacity 0.3s ease-out, transform 0.3s ease-out;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.7); /* Optional: add shadow for visibility */
    }

    .double-tap-heart-animation.show {
      animation: pulseAndFade 0.8s ease-out forwards;
    }

    @keyframes pulseAndFade {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
      }
      30% {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 1;
      }
      70% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="app-container">
    <header class="app-header">
      <div class="drawer-icon" id="drawerIcon">
        <i class="fas fa-bars"></i>
      </div>
      <div class="header-tabs">
        <span class="header-tab active" id="tab-for-you">For You</span>
        <span class="header-tab" id="tab-following">Following</span>
      </div>
    </header>

    <div id="drawerMenu" class="drawer-menu">
      <ul>
        <li id="changeLanguageOption"><i class="fas fa-language"></i> Change Content Language</li>
        </ul>
    </div>

    <div id="reels-feed">
      <div id="loadingGifContainer" class="loading-gif-container">
          <img src="loading.gif" alt="Loading..." class="loading-gif">
      </div>
      </div>
    <div class="footer-nav">
      <a href="#" class="nav-item active" id="nav-home"><i class="fas fa-home"></i><span>Home</span></a>
      <a href="search.html" class="nav-item" id="nav-search"><i class="fas fa-search"></i><span>Search</span></a>
      <a href="create_reel.html" class="nav-item" id="nav-upload"><i class="fas fa-plus-square"></i><span>Create</span></a>
      <a href="notification.html" class="nav-item" id="nav-activity"><i class="fas fa-heart"></i><span>Activity</span></a>
      <a href="profile.html" class="nav-item" id="nav-profile"><i class="fas fa-user"></i><span>Profile</span></a>
    </div>

    <div id="commentsModal" class="comments-modal">
      <div class="comments-header">
        <h3>Comments</h3>
        <button class="close-btn" id="closeCommentsModal">&times;</button>
      </div>
      <div class="comments-list" id="commentsList">
      </div>
      <div class="comment-input-area">
        <input type="text" id="commentInput" placeholder="Add a comment...">
        <button id="postCommentBtn">Post</button>
      </div>
    </div>

    <div id="languageModalOverlay" class="language-modal-overlay">
      <div class="language-modal-content">
        <h2>Choose Your Preferred Languages</h2>
        <p>Select languages to personalize your "For You" feed. You can change this later in your profile.</p>
        <div class="language-options" id="languageOptions">
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="All">
            <span>All</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Hindi">
            <span>Hindi</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Punjabi">
            <span>Punjabi</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="English">
            <span>English</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Bhojpuri">
            <span>Bhojpuri</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Tamil">
            <span>Tamil</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Telugu">
            <span>Telugu</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Bengali">
            <span>Bengali</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Kannada">
            <span>Kannada</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Marathi">
            <span>Marathi</span>
          </label>
          <label class="language-option">
            <input type="checkbox" name="contentLanguage" value="Gujarati">
            <span>Gujarati</span>
          </label>
        </div>
        <button id="saveLanguagesBtn">Save Preferences</button>
        <button id="skipLanguagesBtn" class="skip-btn">Skip for now</button>
      </div>
    </div>

  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-storage-compat.js"></script>


  <script>
     const firebaseConfig = {
  apiKey: "AIzaSyAM2RLdA9wnsy5Nxo29KH7gUsaV4hfbH3U",
  authDomain: "timtom-54c39.firebaseapp.com",
  projectId: "timtom-54c39",
  storageBucket: "timtom-54c39.firebasestorage.app",
  messagingSenderId: "981119735149",
  appId: "1:981119735149:web:b94b2cea3496b7abb4b664",
  measurementId: "G-WNNN6WP21T"
};
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();

    const CLOUDINARY_CLOUD_NAME = "dhc49hdvk";

    let globalMuteState = true;
    let currentPlayingVideo = null;
    let currentMuteIndicator = null;
    let currentUser = null;
    let currentReelIdForComments = null;
    let currentView = 'for-you'; // Default view
    let currentUserFollowing = []; // Initialize as empty array, will be populated on login
    let userContentLanguages = []; // New: User's preferred content languages

    // Cache for user data to reduce Firestore reads
    const usersCache = {};

    // Keep track of viewed reels in the current session to avoid multiple increments for the same reel
    const viewedReelsInSession = new Set(); 

    document.addEventListener("DOMContentLoaded", () => {
      const reelsFeed = document.getElementById('reels-feed');
      const commentsModal = document.getElementById('commentsModal');
      const closeCommentsModalBtn = document.getElementById('closeCommentsModal');
      const commentsList = document.getElementById('commentsList');
      
      // NEW: Direct comment input and post button
      const commentInput = document.getElementById('commentInput');
      const postCommentBtn = document.getElementById('postCommentBtn');

      const tabForYou = document.getElementById('tab-for-you');
      const tabFollowing = document.getElementById('tab-following');

      // NEW Language Selection Modal Elements
      const languageModalOverlay = document.getElementById('languageModalOverlay');
      const languageOptionsContainer = document.getElementById('languageOptions');
      const saveLanguagesBtn = document.getElementById('saveLanguagesBtn');
      const skipLanguagesBtn = document.getElementById('skipLanguagesBtn');

      // NEW Drawer Elements
      const drawerIcon = document.getElementById('drawerIcon');
      const drawerMenu = document.getElementById('drawerMenu');
      const changeLanguageOption = document.getElementById('changeLanguageOption');

      // NEW Loading GIF Element
      const loadingGifContainer = document.getElementById('loadingGifContainer');


      auth.onAuthStateChanged(async (user) => {
        if (!user) {
          alert("Not logged in. Redirecting...");
          window.location.href = 'index.html';
        } else {
          currentUser = user;
          const userDoc = await db.collection("users").doc(user.uid).get();
          window.currentUserUsername = userDoc.exists ? userDoc.data().username : user.email.split('@')[0];
          window.currentUserProfilePic = userDoc.exists && userDoc.data().profilePictureUrl ? userDoc.data().profilePictureUrl : '';
          window.currentUserIsVerified = userDoc.exists && userDoc.data().isVerified === true;
          // Populate currentUserFollowing from userDoc
          currentUserFollowing = userDoc.exists && userDoc.data().following ? userDoc.data().following : [];
          
          // NEW: Check if it's the user's first login or if languages are not set
          const isFirstLogin = userDoc.exists ? userDoc.data().isFirstLogin : true;
          userContentLanguages = userDoc.exists && userDoc.data().contentLanguages ? userDoc.data().contentLanguages : [];

          if (isFirstLogin || userContentLanguages.length === 0) {
              showLanguageSelectionModal();
          } else {
              // Check for reelId in URL parameter when page loads
              const urlParams = new URLSearchParams(window.location.search);
              const reelIdToPlay = urlParams.get('reelId');

              if (reelIdToPlay) {
                  await loadSpecificReelAndOthers(reelIdToPlay);
                  // Clear the URL parameter after loading
                  history.replaceState(null, '', window.location.pathname);
              } else {
                  loadReels(currentView);
              }
          }
        }
      });

      tabForYou.addEventListener('click', () => {
        if (currentView !== 'for-you') {
          tabForYou.classList.add('active');
          tabFollowing.classList.remove('active');
          currentView = 'for-you';
          loadReels(currentView);
        }
      });

      tabFollowing.addEventListener('click', () => {
        if (currentView !== 'following') {
          tabFollowing.classList.add('active');
          tabForYou.classList.remove('active');
          currentView = 'following';
          loadReels(currentView);
        }
      });

      // --- Drawer Menu Event Listeners ---
      drawerIcon.addEventListener('click', (e) => {
          e.stopPropagation(); // Prevent this click from immediately closing the menu via document click
          drawerMenu.classList.toggle('show');
      });

      changeLanguageOption.addEventListener('click', () => {
          drawerMenu.classList.remove('show'); // Hide drawer menu
          showLanguageSelectionModal(); // Show language modal
      });

      document.addEventListener('click', (event) => {
        // Hide drawer menu if clicked outside
        if (drawerMenu.classList.contains('show') && !drawerMenu.contains(event.target) && event.target !== drawerIcon && !drawerIcon.contains(event.target)) {
            drawerMenu.classList.remove('show');
        }
        // Hide comment options menu if clicked outside
        document.querySelectorAll('.comment-options-menu').forEach(menu => {
            if (menu.classList.contains('show') && !menu.contains(event.target) && !event.target.closest('.comment-options-btn')) {
                menu.classList.remove('show');
            }
        });
        // Hide reel options menu if clicked outside
        document.querySelectorAll('.reel-options-menu').forEach(menu => {
            if (menu.classList.contains('show') && !menu.contains(event.target) && !event.target.closest('.reel-options-btn')) {
                menu.classList.remove('show');
            }
        });
      });


      async function getUserData(userId) {
        if (usersCache[userId]) {
          return usersCache[userId];
        }
        const userDoc = await db.collection("users").doc(userId).get();
        const userData = userDoc.exists ? userDoc.data() : null;
        usersCache[userId] = userData;
        return userData;
      }

      async function incrementReelViewCount(reelId) {
          if (!reelId || viewedReelsInSession.has(reelId)) {
              // Only increment if reelId exists and it hasn't been viewed in this session yet
              return;
          }
          const reelRef = db.collection('reels').doc(reelId);
          try {
              await reelRef.update({
                  viewsCount: firebase.firestore.FieldValue.increment(1)
              });
              viewedReelsInSession.add(reelId); // Mark as viewed in this session
              console.log(`Views count incremented for reel: ${reelId}`);
          } catch (error) {
              console.error("Error incrementing views count:", error);
          }
      }

      async function loadReels(view) {
        // Show loading GIF
        loadingGifContainer.classList.remove('hidden');
        reelsFeed.innerHTML = ''; // Clear existing reels

        let query;
        if (view === 'for-you') {
          // NEW: Filter "For You" reels by selected languages
          if (userContentLanguages && userContentLanguages.length > 0 && !userContentLanguages.includes('All')) {
            query = db.collection("reels")
                      .where("language", "in", userContentLanguages)
                      .orderBy("timestamp", "desc");
          } else {
            // Fallback: if no languages selected OR 'All' is selected, show all reels
            query = db.collection("reels").orderBy("timestamp", "desc");
          }
        } else if (view === 'following') {
          if (!currentUser || currentUserFollowing.length === 0) {
            reelsFeed.innerHTML = `<p style="text-align:center; padding-top:50vh; transform:translateY(-50%);">You are not following anyone yet. Explore "For You" to find new creators!</p>`;
            loadingGifContainer.classList.add('hidden'); // Hide GIF if no content
            return;
          }
          // Query for reels from users the current user is following
          query = db.collection("reels").where("userId", "in", currentUserFollowing).orderBy("timestamp", "desc");
        }

        const snapshot = await query.get();
        let reelsDocs = snapshot.docs;

        if (view === 'for-you') {
            // Shuffle reels for a "For You" like experience
            for (let i = reelsDocs.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [reelsDocs[i], reelsDocs[j]] = [reelsDocs[j], reelsDocs[i]];
            }
        }
        
        await renderReels(reelsDocs);
        loadingGifContainer.classList.add('hidden'); // Hide GIF after reels are rendered
      }

      async function loadSpecificReelAndOthers(targetReelId) {
          // Show loading GIF
          loadingGifContainer.classList.remove('hidden');
          reelsFeed.innerHTML = ''; // Clear existing reels
          
          let reelsDocs = [];
          let targetReelDoc = null;

          // Fetch the specific reel first
          const specificReelSnapshot = await db.collection("reels").doc(targetReelId).get();
          if (specificReelSnapshot.exists) {
              targetReelDoc = specificReelSnapshot;
          }

          // Fetch all other reels (for 'for-you' logic, or all if not following)
          let allReelsQuery;
          if (currentView === 'following' && currentUserFollowing.length > 0) {
              allReelsQuery = db.collection("reels").where("userId", "in", currentUserFollowing).orderBy("timestamp", "desc");
          } else {
             // NEW: Filter 'For You' when loading specific reel and others by language
             if (userContentLanguages && userContentLanguages.length > 0 && !userContentLanguages.includes('All')) {
                allReelsQuery = db.collection("reels")
                                  .where("language", "in", userContentLanguages)
                                  .orderBy("timestamp", "desc");
             } else {
                allReelsQuery = db.collection("reels").orderBy("timestamp", "desc");
             }
          }
          const allReelsSnapshot = await allReelsQuery.get();
          
          // Filter out the target reel from the main list if it was found
          const otherReelsDocs = allReelsSnapshot.docs.filter(doc => doc.id !== targetReelId);

          if (currentView === 'for-you') {
              // Shuffle other reels only for 'for-you'
              for (let i = otherReelsDocs.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [otherReelsDocs[i], otherReelsDocs[j]] = [otherReelsDocs[j], otherReelsDocs[i]];
              }
          }

          // Combine the target reel (if found) with the shuffled others
          if (targetReelDoc) {
              reelsDocs = [targetReelDoc, ...otherReelsDocs];
          } else {
              reelsDocs = otherReelsDocs; // If target reel not found, just show others
          }

          await renderReels(reelsDocs, targetReelId);
          loadingGifContainer.classList.add('hidden'); // Hide GIF after reels are rendered
      }


      async function renderReels(reelsDocs, initialReelId = null) {
        if (reelsDocs.length === 0) {
            reelsFeed.innerHTML = `<p style="text-align:center; padding-top:50vh; transform:translateY(-50%);">No reels to display for this section. Check back later!</p>`;
            return;
        }

        let initialScrollDone = false; // Flag to ensure scroll only happens once

        // --- Intersection Observer for Lazy Loading and Playback ---
        // Root margin increased to preload videos slightly before they are fully in view.
        // This helps in smoother transitions when scrolling.
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              const video = entry.target.querySelector('video');
              const reelId = entry.target.dataset.reelId;
              const indicator = entry.target.querySelector('.mute-indicator');

              if (entry.isIntersecting) {
                // Set the video src only when it's intersecting
                if (!video.src && video.dataset.src) {
                    video.src = video.dataset.src;
                    video.load(); // Start loading the video
                }
                
                // Play only if it's mostly in view
                if (entry.intersectionRatio >= 0.8) {
                    video.muted = globalMuteState;
                    video.currentTime = 0; // Reset video to start
                    video.play().catch(error => console.error("Video play failed:", error));
                    currentPlayingVideo = video;
                    currentMuteIndicator = indicator;
                    indicator.classList.toggle('hidden', !globalMuteState);
                    indicator.innerHTML = `<i class="fas ${globalMuteState ? 'fa-volume-mute' : 'fa-volume-up'}"></i>`;
                    
                    // Increment view count when a reel starts playing
                    incrementReelViewCount(reelId);

                    // If an initial reel was specified and we haven't scrolled to it yet
                    if (initialReelId && !initialScrollDone && reelId === initialReelId) {
                        video.scrollIntoView({ behavior: 'auto', block: 'start' });
                        initialScrollDone = true;
                    }
                } else {
                    // Pause if partially intersecting but not enough for full play
                    video.pause();
                }

              } else {
                video.pause();
                // When a video leaves the viewport, you might consider clearing its src to free up memory.
                // However, for typical short reels, keeping it buffered might be fine.
                // If you notice memory issues, uncomment the next line:
                // video.removeAttribute('src'); 
                // video.load(); // Reset the video element state
                if (indicator) {
                    indicator.classList.add('hidden');
                }
              }
            });
          }, { threshold: [0, 0.2, 0.4, 0.6, 0.8, 1.0], rootMargin: '100px 0px 100px 0px' }); // Load videos 100px before they enter view

          for (const doc of reelsDocs) { // Use the (potentially filtered/shuffled) reelsDocs
            const data = doc.data();
            const reel = document.createElement('div');
            reel.className = 'reel-item';
            reel.dataset.reelId = doc.id; // Store reel ID on the element
            reel.dataset.userId = data.userId; // Store uploader userId for easy access

            const uploaderUserId = data.userId;
            const uploaderData = await getUserData(uploaderUserId);
            
            const uploaderUsername = uploaderData && uploaderData.username ? uploaderData.username : data.username || 'User';
            const uploaderProfilePic = uploaderData && uploaderData.profilePictureUrl ? uploaderData.profilePictureUrl : '';
            const uploaderIsVerified = uploaderData && uploaderData.isVerified === true;

            const usernameFirstLetter = uploaderUsername ? uploaderUsername.charAt(0).toUpperCase() : '?';
            
            const profilePicHtml = uploaderProfilePic
              ? `<img src="${uploaderProfilePic}" alt="Profile" class="profile-pic">`
              : `<div class="profile-pic placeholder">${usernameFirstLetter}</div>`;
            
            // Replaced Font Awesome with SVG for verified tick
            const verifiedTickHtml = uploaderIsVerified ? `
                <svg class="verified-tick-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="256" height="256" viewBox="0 0 256 256" xml:space="preserve">
                    <g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: none; fill-rule: nonzero; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)">
                        <circle cx="45" cy="45" r="45" />
                        <path d="M 41.134 59.667 c -1.146 0 -2.291 -0.436 -3.167 -1.304 l -13.46 -13.335 c -1.766 -1.749 -1.779 -4.599 -0.03 -6.364 c 1.749 -1.767 4.598 -1.778 6.364 -0.03 l 10.344 10.249 l 18.028 -17.297 c 1.793 -1.721 4.642 -1.662 6.362 0.132 c 1.721 1.793 1.662 4.642 -0.132 6.362 L 44.249 58.414 C 43.378 59.25 42.255 59.667 41.134 59.667 z" stroke-linecap="round"/>
                    </g>
                </svg>
            ` : '';

            // Determine if current user follows this uploader
            const isFollowing = currentUser && currentUser.uid !== uploaderUserId && currentUserFollowing.includes(uploaderUserId);
            const followButtonText = isFollowing ? 'Following' : 'Follow';
            const followButtonClass = isFollowing ? 'following' : '';
            const followButtonHtml = currentUser && currentUser.uid !== uploaderUserId ? 
                `<button class="follow-button ${followButtonClass}" data-user-id="${uploaderUserId}">${followButtonText}</button>` : '';


            const likedByCurrentUser = currentUser && data.likes && data.likes.includes(currentUser.uid);
            const likeIconClass = likedByCurrentUser ? 'fas fa-heart liked' : 'far fa-heart';
            const likeCount = data.likes ? data.likes.length : 0;

            const commentsSnapshot = await db.collection("reels").doc(doc.id).collection("comments").get();
            const commentCount = commentsSnapshot.size;

            const isReelOwner = currentUser && data.userId === currentUser.uid;

            // Build reel options menu content dynamically
            let reelOptionsMenuContent = '';
            // Only add unfollow if the reel owner is NOT the current user AND they are currently following
            if (currentUser && currentUser.uid !== uploaderUserId) {
                // We'll update the text dynamically based on the isFollowing state
                reelOptionsMenuContent += `<button class="toggle-follow-option" data-user-id="${uploaderUserId}">${isFollowing ? 'Unfollow' : 'Follow'}</button>`;
            }
            if (isReelOwner) { // Delete option for your own reels
                reelOptionsMenuContent += `<button class="delete-reel-btn" data-reel-id="${doc.id}" data-video-url="${data.videoUrl}">Delete Reel</button>`;
            }

            const reelOptionsMenuHtml = `
                <div class="options-container">
                    <button class="options-btn reel-options-btn"><i class="fas fa-ellipsis-h"></i></button>
                    <div class="reel-options-menu">
                        ${reelOptionsMenuContent}
                    </div>
                </div>
            `;

            // New HTML for the rotating disk
            const rotatingDiskHtml = `
                <div class="rotating-disk-container">
                    <div class="rotating-disk">
                        ${uploaderProfilePic ? `<img src="${uploaderProfilePic}" alt="Audio source" />` : `<div class="placeholder">${usernameFirstLetter}</div>`}
                    </div>
                </div>
            `;

            const viewsCount = data.viewsCount || 0; // Get viewsCount from data, default to 0

            reel.innerHTML = `
              <video loop playsinline preload="metadata" ${globalMuteState ? 'muted' : ''} data-src="${data.videoUrl}">
              </video>
              <div class="mute-indicator ${globalMuteState ? '' : 'hidden'}"><i class="fas ${globalMuteState ? 'fa-volume-mute' : 'fa-volume-up'}"></i></div>
              <div class="reel-overlay">
                <div class="reel-username-line">
                  <span class="reel-username">@${uploaderUsername}</span>
                  ${verifiedTickHtml}
                  ${followButtonHtml}
                </div>
                <p class="reel-caption">${data.caption || ''}</p>
              </div>
              <div class="profile-pic-container">
                ${profilePicHtml}
              </div>
              <div class="reel-actions">
                <div class="reel-action-item like-button" data-reel-id="${doc.id}">
                  <i class="${likeIconClass}"></i>
                  <span class="like-count">${likeCount}</span>
                </div>
                <div class="reel-action-item comment-button" data-reel-id="${doc.id}">
                  <i class="fas fa-comment"></i>
                  <span>${commentCount}</span>
                </div>
                <div class="reel-action-item">
                    ${reelOptionsMenuHtml}
                </div>
              </div>
              ${rotatingDiskHtml}
              <div class="views-count-display">
                  <i class="fas fa-eye"></i> ${viewsCount} views
              </div>
              <div class="double-tap-heart-animation"></div> `;

            const videoElement = reel.querySelector('video');
            const muteIndicator = reel.querySelector('.mute-indicator');
            
            // --- Mute/Unmute functionality now only on the mute indicator icon ---
            muteIndicator.addEventListener('click', () => {
              globalMuteState = !globalMuteState;
              // Only update the currently playing video and its indicator
              if (currentPlayingVideo) {
                  currentPlayingVideo.muted = globalMuteState;
              }
              if (currentMuteIndicator) {
                  currentMuteIndicator.classList.toggle('hidden', !globalMuteState);
                  currentMuteIndicator.innerHTML = `<i class="fas ${globalMuteState ? 'fa-volume-mute' : 'fa-volume-up'}"></i>`;
              }
            });

            // --- Double-Tap/Click to Like Logic ---
            let lastClickTime = 0;
            videoElement.addEventListener('click', async (event) => {
                const clickTime = new Date().getTime();
                if (clickTime - lastClickTime < 300) { // Check for double-click within 300ms
                    event.preventDefault(); // Prevent default video controls if any
                    const reelId = reel.dataset.reelId;
                    const likeButton = reel.querySelector('.like-button');
                    await toggleLike(reelId, likeButton); // Use a new function for toggling like
                    triggerHeartAnimation(reel); // Trigger the animation
                }
                lastClickTime = clickTime;
            });


            // Follow Button Listener (direct button)
            const reelFollowButton = reel.querySelector('.follow-button');
            if (reelFollowButton) {
                reelFollowButton.addEventListener('click', async (e) => {
                    const targetUserId = e.target.dataset.userId;
                    await toggleFollow(targetUserId, e.target); // Pass the specific button element
                });
            }

            const likeButton = reel.querySelector('.like-button');
            likeButton.addEventListener('click', async () => {
              const reelId = likeButton.dataset.reelId;
              await toggleLike(reelId, likeButton); // Use the new function here as well
            });

            reel.querySelector('.comment-button').addEventListener('click', (event) => {
              if (!currentUser) {
                alert("Please log in to view or post comments.");
                return;
              }
              currentReelIdForComments = event.currentTarget.dataset.reelId;
              openCommentsModal(currentReelIdForComments);
            });

            // Always add listener for reel options button now
            const reelOptionsBtn = reel.querySelector('.reel-options-btn');
            const reelOptionsMenu = reel.querySelector('.reel-options-menu');
            
            if (reelOptionsBtn && reelOptionsMenu) { // Ensure they exist
                reelOptionsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.reel-options-menu').forEach(menu => {
                        if (menu !== reelOptionsMenu) menu.classList.remove('show');
                    });
                    reelOptionsMenu.classList.toggle('show');
                });

                // Add listener for delete button if it exists in this menu
                const deleteBtn = reelOptionsMenu.querySelector('.delete-reel-btn');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const reelIdToDelete = e.currentTarget.dataset.reelId;
                        const videoUrlToDelete = e.currentTarget.dataset.videoUrl;
                        deleteReel(reelIdToDelete, videoUrlToDelete);
                        reelOptionsMenu.classList.remove('show'); // Hide menu after action
                    });
                }
                
                // Add listener for toggle follow option if it exists in this menu
                const toggleFollowOption = reelOptionsMenu.querySelector('.toggle-follow-option');
                if (toggleFollowOption) {
                    toggleFollowOption.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const targetUserId = e.currentTarget.dataset.userId;
                        await toggleFollow(targetUserId, null); // Pass null as we're not updating a *specific* direct follow button here
                        reelOptionsMenu.classList.remove('show'); // Hide menu after action
                    });
                }
            }


            reelsFeed.appendChild(reel);
            observer.observe(reel);
          }
      }

      // --- NEW Function to handle liking/unliking a reel ---
      async function toggleLike(reelId, likeButtonElement) {
            if (!currentUser) {
                alert("Please log in to like reels.");
                return;
            }
            const reelRef = db.collection("reels").doc(reelId);

            try {
                const reelDoc = await reelRef.get();
                if (reelDoc.exists) {
                    const currentLikes = reelDoc.data().likes || [];
                    const likeIcon = likeButtonElement.querySelector('i');
                    const likeCountSpan = likeButtonElement.querySelector('.like-count');
                    const uploaderUserId = reelDoc.data().userId;

                    if (currentLikes.includes(currentUser.uid)) {
                        // Unlike
                        await reelRef.update({
                            likes: firebase.firestore.FieldValue.arrayRemove(currentUser.uid)
                        });
                        likeIcon.classList.remove('liked');
                        likeIcon.classList.add('far');
                        likeCountSpan.textContent = currentLikes.length - 1;
                    } else {
                        // Like
                        await reelRef.update({
                            likes: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
                        });
                        likeIcon.classList.add('liked');
                        likeIcon.classList.remove('far');
                        likeIcon.classList.add('fas');
                        likeCountSpan.textContent = currentLikes.length + 1;

                        if (currentUser.uid !== uploaderUserId) {
                            await db.collection("notifications").add({
                                type: "like",
                                fromUserId: currentUser.uid,
                                toUserId: uploaderUserId,
                                reelId: reelId,
                                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                                read: false
                            });
                        }
                    }
                }
            } catch (error) {
                console.error("Error updating like:", error);
            }
        }

        // --- Heart Animation Function ---
        function triggerHeartAnimation(reelElement) {
            const heartAnimationDiv = reelElement.querySelector('.double-tap-heart-animation');
            heartAnimationDiv.innerHTML = '<i class="fas fa-heart"></i>'; // Add heart icon
            heartAnimationDiv.classList.add('show'); // Trigger animation

            // Remove after animation completes
            setTimeout(() => {
                heartAnimationDiv.classList.remove('show');
                heartAnimationDiv.innerHTML = '';
            }, 800); // Adjust time to match CSS animation duration
        }


      // --- Functions for comments modal ---

      closeCommentsModalBtn.addEventListener('click', () => {
        commentsModal.classList.remove('show');
        commentsList.innerHTML = '';
        commentInput.value = ''; // Clear input when closing
      });

      // NEW: Event listeners for the comment input and post button
      postCommentBtn.addEventListener('click', () => {
        const commentText = commentInput.value.trim();
        if (commentText === "") {
          alert("Comment cannot be empty.");
          return;
        }
        postComment(commentText);
        commentInput.value = ''; // Clear input after posting
      });

      commentInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) { // Shift+Enter for new line
            event.preventDefault(); // Prevent default new line
            postCommentBtn.click(); // Trigger post button click
        }
      });


      async function openCommentsModal(reelId) {
        commentsList.innerHTML = '<p style="text-align: center; color: #aaa;">Loading comments...</p>';
        commentsModal.classList.add('show');
        commentInput.focus(); // Focus the input when modal opens
        await loadComments(reelId);
      }

      async function loadComments(reelId) {
        commentsList.innerHTML = '';
        try {
          const commentsRef = db.collection("reels").doc(reelId).collection("comments").orderBy("timestamp", "asc");
          const snapshot = await commentsRef.get();

          if (snapshot.empty) {
            commentsList.innerHTML = '<p style="text-align: center; color: #aaa;">No comments yet. Be the first to comment!</p>';
            return;
          }

          for (const doc of snapshot.docs) {
            const commentData = doc.data();
            const commentUser = await getUserData(commentData.userId);
            const commentUsername = commentUser && commentUser.username ? commentUser.username : 'Anonymous';
            const commentUserProfilePic = commentUser && commentUser.profilePictureUrl ? commentUser.profilePictureUrl : '';
            const commentUserFirstLetter = commentUsername ? commentUsername.charAt(0).toUpperCase() : '?';
            const commentUserIsVerified = commentUser && commentUser.isVerified === true;


            const profilePicHtml = commentUserProfilePic
              ? `<img src="${commentUserProfilePic}" alt="Profile" class="comment-user-pic">`
              : `<div class="comment-user-pic placeholder">${commentUserFirstLetter}</div>`;
            
            // Replaced Font Awesome with SVG for comment verified tick
            const verifiedTickHtml = commentUserIsVerified ? `
                <svg class="verified-tick-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="256" height="256" viewBox="0 0 256 256" xml:space="preserve">
                    <g style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; fill: none; fill-rule: nonzero; opacity: 1;" transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)">
                        <circle cx="45" cy="45" r="45" />
                        <path d="M 41.134 59.667 c -1.146 0 -2.291 -0.436 -3.167 -1.304 l -13.46 -13.335 c -1.766 -1.749 -1.779 -4.599 -0.03 -6.364 c 1.749 -1.767 4.598 -1.778 6.364 -0.03 l 10.344 10.249 l 18.028 -17.297 c 1.793 -1.721 4.642 -1.662 6.362 0.132 c 1.721 1.793 1.662 4.642 -0.132 6.362 L 44.249 58.414 C 43.378 59.25 42.255 59.667 41.134 59.667 z" stroke-linecap="round"/>
                    </g>
                </svg>
            ` : '';
            
            const likedByCurrentUser = currentUser && commentData.likes && commentData.likes.includes(currentUser.uid);
            const commentLikeIconClass = likedByCurrentUser ? 'fas fa-heart liked' : 'far fa-heart';
            const commentLikeCount = commentData.likes ? commentData.likes.length : 0;

            const isOwner = currentUser && commentData.userId === currentUser.uid;
            const optionsMenuHtml = isOwner ? `
                <div class="comment-options">
                    <button class="comment-options-btn"><i class="fas fa-ellipsis-h"></i></button>
                    <div class="comment-options-menu">
                        <button class="delete-comment-btn" data-comment-id="${doc.id}">Delete</button>
                    </div>
                </div>
            ` : '';

            const commentItem = document.createElement('div');
            commentItem.className = 'comment-item';
            commentItem.innerHTML = `
              ${profilePicHtml}
              <div class="comment-content">
                <span class="comment-username">${commentUsername} ${verifiedTickHtml}</span>
                <span class="comment-text">${commentData.text}</span>
                <div class="comment-actions">
                  <span class="like-comment-btn" data-comment-id="${doc.id}"><i class="${commentLikeIconClass}"></i></span>
                  <span class="like-count">${commentLikeCount}</span>
                  <span>${formatTimestamp(commentData.timestamp)}</span>
                </div>
              </div>
              ${optionsMenuHtml}
            `;
            commentsList.appendChild(commentItem);

            if (isOwner) {
                commentItem.querySelector('.comment-options-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const menu = commentItem.querySelector('.comment-options-menu');
                    document.querySelectorAll('.comment-options-menu').forEach(m => {
                        if (m !== menu) m.classList.remove('show');
                    });
                    menu.classList.toggle('show');
                });
                commentItem.querySelector('.delete-comment-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const commentIdToDelete = e.currentTarget.dataset.commentId;
                    deleteComment(currentReelIdForComments, commentIdToDelete);
                });
            }

            commentItem.querySelector('.like-comment-btn').addEventListener('click', async (e) => {
                if (!currentUser) {
                    alert("Please log in to like comments.");
                    return;
                }
                const commentId = e.currentTarget.dataset.commentId;
                await toggleCommentLike(currentReelIdForComments, commentId, e.currentTarget);
            });
          }
          commentsList.scrollTop = commentsList.scrollHeight;
        } catch (error) {
          console.error("Error loading comments:", error);
          commentsList.innerHTML = '<p style="text-align: center; color: red;">Failed to load comments.</p>';
        }
      }

      // postComment function now gets commentText directly from the input
      async function postComment(commentText) {
        if (!currentUser || !currentReelIdForComments || commentText === "") {
          alert("Invalid comment or reel not selected.");
          return;
        }

        try {
          await db.collection("reels").doc(currentReelIdForComments).collection("comments").add({
            userId: currentUser.uid,
            text: commentText,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            likes: []
          });
          
          await loadComments(currentReelIdForComments); // Reload comments to show the new one
          
          const reelItemCommentCountSpan = document.querySelector(`.reel-action-item.comment-button[data-reel-id="${currentReelIdForComments}"] span`);
          if (reelItemCommentCountSpan) {
            const currentCount = parseInt(reelItemCommentCountSpan.textContent) || 0;
            reelItemCommentCountSpan.textContent = currentCount + 1;
          }

          const reelRef = await db.collection("reels").doc(currentReelIdForComments).get();
          if (reelRef.exists && currentUser.uid !== reelRef.data().userId) {
              await db.collection("notifications").add({
                type: "comment",
                fromUserId: currentUser.uid,
                toUserId: reelRef.data().userId,
                reelId: currentReelIdForComments,
                commentText: commentText,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                read: false
              });
          }

        } catch (error) {
          console.error("Error posting comment:", error);
          alert("Failed to post comment. Please try again.");
        }
      }

      async function deleteComment(reelId, commentId) {
        if (!confirm("Are you sure you want to delete this comment?")) {
            return;
        }
        try {
            await db.collection("reels").doc(reelId).collection("comments").doc(commentId).delete();
            alert("Comment deleted successfully!");
            await loadComments(reelId);
            
            const reelItemCommentCountSpan = document.querySelector(`.reel-action-item.comment-button[data-reel-id="${currentReelIdForComments}"] span`);
            if (reelItemCommentCountSpan) {
                const currentCount = parseInt(reelItemCommentCountSpan.textContent) || 0;
                reelItemCommentCountSpan.textContent = Math.max(0, currentCount - 1);
            }
        } catch (error) {
            console.error("Error deleting comment:", error);
            alert("Failed to delete comment. Please try again.");
        }
      }

      async function toggleCommentLike(reelId, commentId, likeButtonElement) {
        const commentRef = db.collection("reels").doc(reelId).collection("comments").doc(commentId);
        try {
            const commentDoc = await commentRef.get();
            if (commentDoc.exists) {
                const currentLikes = commentDoc.data().likes || [];
                const likeIcon = likeButtonElement.querySelector('i');
                const likeCountSpan = likeButtonElement.nextElementSibling;

                if (currentLikes.includes(currentUser.uid)) {
                    await commentRef.update({
                        likes: firebase.firestore.FieldValue.arrayRemove(currentUser.uid)
                    });
                    likeIcon.classList.remove('fas', 'liked');
                    likeIcon.classList.add('far');
                    likeCountSpan.textContent = currentLikes.length - 1;
                } else {
                    await commentRef.update({
                        likes: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
                    });
                    likeIcon.classList.remove('far');
                    likeIcon.classList.add('fas', 'liked');
                    likeCountSpan.textContent = currentLikes.length + 1;

                    const commentData = commentDoc.data();
                    if (currentUser.uid !== commentData.userId) {
                        await db.collection("notifications").add({
                            type: "comment_like",
                            fromUserId: currentUser.uid,
                            toUserId: commentData.userId,
                            reelId: reelId,
                            commentId: commentId,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                            read: false
                        });
                    }
                }
            }
        } catch (error) {
            console.error("Error updating comment like:", error);
        }
      }

      async function deleteReel(reelId, videoUrl) {
        if (!currentUser) {
            alert("You must be logged in to delete reels.");
            return;
        }

        if (!confirm("Are you sure you want to delete this reel? This action cannot be undone.")) {
            return;
        }

        try {
            // 1. Delete comments associated with the reel
            const commentsSnapshot = await db.collection("reels").doc(reelId).collection("comments").get();
            const batch = db.batch();
            commentsSnapshot.docs.forEach(doc => {
                batch.delete(doc.ref);
            });
            await batch.commit();

            // 2. Delete the video file from Firebase Storage
            // Cloudinary URLs typically don't need Firebase Storage deletion.
            // If you are using Firebase Storage for videos, this part is relevant.
            // Assuming Cloudinary based on your config, this might not be needed.
            // If it was Firebase Storage, the URL would be like:
            // gs://timtom-54c39.appspot.com/videos/somefile.mp4
            // You would extract the path from that.
            // For Cloudinary, you usually delete via their API, not directly from the URL.
            // For now, I'll comment out the Firebase Storage part as you mentioned Cloudinary.
            /*
            const videoStorageRef = storage.refFromURL(videoUrl);
            await videoStorageRef.delete();
            console.log("Video deleted from Firebase Storage:", videoUrl);
            */
            // You might need to add Cloudinary deletion logic here if you're storing the public_id in Firestore
            // and want to delete the file from Cloudinary as well.

            // 3. Delete the reel document from Firestore
            await db.collection("reels").doc(reelId).delete();
            alert("Reel deleted successfully!");

            // Remove the reel from the DOM immediately
            const deletedReelElement = document.querySelector(`.reel-item[data-reel-id="${reelId}"]`);
            if (deletedReelElement) {
                deletedReelElement.remove();
                // If the current playing reel was deleted, ensure no video is playing
                if (currentPlayingVideo && currentPlayingVideo.closest('.reel-item').dataset.reelId === reelId) {
                    currentPlayingVideo = null;
                    currentMuteIndicator = null;
                }
            }
            
            // If the feed becomes empty, display a message
            if (reelsFeed.children.length === 0) {
                reelsFeed.innerHTML = `<p style="text-align:center; padding-top:50vh; transform:translateY(-50%);">No reels to display for this section. Check back later!</p>`;
            } else {
                 // Try to play the next available reel if any
                const firstReel = reelsFeed.querySelector('.reel-item');
                if (firstReel) {
                    const video = firstReel.querySelector('video');
                    const indicator = firstReel.querySelector('.mute-indicator');
                    if (video && indicator) {
                        // Ensure video src is loaded before attempting to play
                        if (!video.src && video.dataset.src) {
                            video.src = video.dataset.src;
                            video.load();
                        }
                        video.muted = globalMuteState;
                        video.currentTime = 0;
                        video.play().catch(() => {});
                        currentPlayingVideo = video;
                        currentMuteIndicator = indicator;
                        indicator.classList.toggle('hidden', !globalMuteState);
                        indicator.innerHTML = `<i class="fas ${globalMuteState ? 'fa-volume-mute' : 'fa-volume-up'}"></i>`;
                        incrementReelViewCount(firstReel.dataset.reelId);
                    }
                }
            }


        } catch (error) {
            console.error("Error deleting reel:", error);
            alert("Failed to delete reel. Please try again.");
        }
      }

      // --- Follow/Unfollow Logic ---
      async function toggleFollow(targetUserId, buttonElement) {
        if (!currentUser) {
          alert("You must be logged in to follow or unfollow users.");
          return;
        }

        if (currentUser.uid === targetUserId) {
          // Prevent self-follow/unfollow
          return;
        }

        const currentUserRef = db.collection('users').doc(currentUser.uid);
        const targetUserRef = db.collection('users').doc(targetUserId);

        try {
          // Use the global currentUserFollowing array
          const isCurrentlyFollowing = currentUserFollowing.includes(targetUserId);

          if (isCurrentlyFollowing) {
            // Unfollow
            await currentUserRef.update({
              following: firebase.firestore.FieldValue.arrayRemove(targetUserId)
            });
            await targetUserRef.update({
              followers: firebase.firestore.FieldValue.arrayRemove(currentUser.uid)
            });
            // Update the in-memory following list for the current user
            currentUserFollowing = currentUserFollowing.filter(id => id !== targetUserId);
            
            alert(`You have unfollowed this user.`);
          } else {
            // Follow
            await currentUserRef.update({
              following: firebase.firestore.FieldValue.arrayUnion(targetUserId)
            });
            await targetUserRef.update({
              followers: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
            });
            // Update the in-memory following list for the current user
            currentUserFollowing.push(targetUserId);
            alert(`You are now following this user!`);

            // Add a notification for the followed user
            await db.collection("notifications").add({
                type: "follow",
                fromUserId: currentUser.uid,
                toUserId: targetUserId,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                read: false
            });
          }

          // **Real-time UI update for all relevant buttons without page refresh**
          document.querySelectorAll(`.reel-item[data-user-id="${targetUserId}"]`).forEach(reelItem => {
              const followBtn = reelItem.querySelector('.follow-button');
              const toggleFollowOption = reelItem.querySelector('.toggle-follow-option');

              if (isCurrentlyFollowing) {
                  // If unfollowed
                  if (followBtn) {
                      followBtn.textContent = 'Follow';
                      followBtn.classList.remove('following');
                  }
                  if (toggleFollowOption) {
                      toggleFollowOption.textContent = 'Follow';
                  }
              } else {
                  // If followed
                  if (followBtn) {
                      followBtn.textContent = 'Following';
                      followBtn.classList.add('following');
                  }
                  if (toggleFollowOption) {
                      toggleFollowOption.textContent = 'Unfollow';
                  }
              }
          });

          // If the 'Following' tab is active, we might need to filter reels
          // This is a more complex real-time update. For now, if the 'Following' tab is active
          // and a user is unfollowed, their reels will remain until a full refresh or tab switch.
          // For truly dynamic 'Following' feed, you'd need to re-filter the current DOM elements
          // or re-render only the 'Following' feed if the active tab is 'Following'.
          // A simpler approach for the 'Following' tab would be to just reload that tab if it's active.
          if (currentView === 'following') {
              loadReels(currentView); // Reload only if currently on 'Following' tab
          }

        } catch (error) {
          console.error("Error toggling follow:", error);
          alert("Failed to perform follow/unfollow. Please try again.");
        }
      }

      function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = timestamp.toDate();
        const now = new Date();
        const diff = now.getTime() - date.getTime();

        const seconds = Math.floor(diff / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(minutes / (60 * 24));
        const months = Math.floor(days / 30);
        const years = Math.floor(days / 365);


        if (seconds < 60) {
            return seconds === 0 ? 'just now' : `${seconds}s ago`;
        } else if (minutes < 60) {
            return `${minutes}m ago`;
        } else if (hours < 24) {
            return `${hours}h ago`;
        } else if (days < 30) {
            return `${days}d ago`;
        } else if (months < 12) {
            return `${months}mo ago`;
        } else {
            return `${years}y ago`;
        }
      }

      // --- NEW Language Selection Modal Functions ---

      function showLanguageSelectionModal() {
        languageModalOverlay.classList.add('show');
        // Pre-select any languages already saved (if any, in case user comes back to modify)
        document.querySelectorAll('input[name="contentLanguage"]').forEach(checkbox => {
            checkbox.checked = userContentLanguages.includes(checkbox.value);
            // Visually update the label based on checked state
            checkbox.nextElementSibling.style.backgroundColor = checkbox.checked ? '#007bff' : '#333';
            checkbox.nextElementSibling.style.borderColor = checkbox.checked ? '#007bff' : '#444';
            checkbox.nextElementSibling.style.color = checkbox.checked ? 'white' : 'white';
        });
      }

      saveLanguagesBtn.addEventListener('click', async () => {
        let selectedLanguages = Array.from(document.querySelectorAll('input[name="contentLanguage"]:checked'))
                                     .map(checkbox => checkbox.value);
        
        // If 'All' is selected, store an empty array or specific marker that means "all"
        // For simplicity, let's store ['All'] if 'All' is chosen, and treat it specially when querying.
        if (selectedLanguages.includes('All')) {
            selectedLanguages = ['All']; // If 'All' is selected, override other selections
        } else if (selectedLanguages.length === 0) {
             // If no languages are selected (and 'All' wasn't selected),
             // consider this as an empty preference set, which will default to all content.
             selectedLanguages = []; 
        }

        if (currentUser) {
            try {
                await db.collection("users").doc(currentUser.uid).update({
                    contentLanguages: selectedLanguages,
                    isFirstLogin: false // Mark as not first login
                });
                userContentLanguages = selectedLanguages; // Update in-memory array
                languageModalOverlay.classList.remove('show');
                alert('Your language preferences have been saved!');
                // Reload reels with new preferences
                loadReels(currentView); 
            } catch (error) {
                console.error("Error saving language preferences:", error);
                alert("Failed to save preferences. Please try again.");
            }
        }
      });

      skipLanguagesBtn.addEventListener('click', async () => {
        if (currentUser) {
            try {
                await db.collection("users").doc(currentUser.uid).update({
                    isFirstLogin: false, // Mark as not first login, even if no languages were chosen
                    contentLanguages: [] // Explicitly set to empty if skipping
                });
                userContentLanguages = []; // Ensure preferences are empty
                languageModalOverlay.classList.remove('show');
                alert('You can set your language preferences later in your profile.');
                loadReels(currentView); // Load all reels if skipped
            } catch (error) {
                console.error("Error skipping language preferences:", error);
                alert("Failed to skip preferences. Please try again.");
            }
        }
      });

      // Add event listener to each checkbox label for styling
      languageOptionsContainer.addEventListener('change', (event) => {
        if (event.target.type === 'checkbox' && event.target.name === 'contentLanguage') {
          const span = event.target.nextElementSibling;
          if (event.target.checked) {
            span.style.backgroundColor = '#007bff';
            span.style.borderColor = '#007bff';
            span.style.color = 'white';
            // If 'All' is checked, uncheck all others
            if (event.target.value === 'All') {
                document.querySelectorAll('input[name="contentLanguage"]').forEach(checkbox => {
                    if (checkbox.value !== 'All') {
                        checkbox.checked = false;
                        checkbox.nextElementSibling.style.backgroundColor = '#333';
                        checkbox.nextElementSibling.style.borderColor = '#444';
                        checkbox.nextElementSibling.style.color = 'white';
                    }
                });
            } else { // If any other language is checked, uncheck 'All'
                const allCheckbox = document.querySelector('input[name="contentLanguage"][value="All"]');
                if (allCheckbox && allCheckbox.checked) {
                    allCheckbox.checked = false;
                    allCheckbox.nextElementSibling.style.backgroundColor = '#333';
                    allCheckbox.nextElementSibling.style.borderColor = '#444';
                    allCheckbox.nextElementSibling.style.color = 'white';
                }
            }
          } else {
            span.style.backgroundColor = '#333';
            span.style.borderColor = '#444';
            span.style.color = 'white';
          }
        }
      });

    }); // End DOMContentLoaded
  </script>
</body>
</html>
